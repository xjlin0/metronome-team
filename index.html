<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>å¤šäººåŒæ­¥ç¯€æ‹å™¨ MVP</title>

<!-- QR + QR scan libs -->
<script src="https://cdn.jsdelivr.net/npm/qrcode/build/qrcode.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jsqr/dist/jsQR.js"></script>

<style>
  :root { --bg:#0f1720; --panel:#0b1220; --muted:#9aa7b2; --accent:#36a3ff; --accent-strong:#ff7a7a; }
  body { margin:0; font-family: "Noto Sans TC", Arial, sans-serif; background:var(--bg); color:#e6eef6; display:flex; justify-content:center; }
  .wrap { width:100%; max-width:980px; padding:24px; }
  header { text-align:center; margin-bottom:8px; }
  h1 { margin:0; font-size:20px; }
  .panel { background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:16px; border-radius:12px; box-shadow:0 8px 30px rgba(0,0,0,0.6); }
  .controls { display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap; margin-bottom:12px; }
  .control-group { display:flex; gap:8px; align-items:center; }
  label { font-size:14px; color:var(--muted); }
  input[type="range"] { width:260px; }
  select, input[type=text] { padding:6px 8px; font-size:14px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); background:transparent; color:#e6eef6; }
  button { padding:8px 12px; border-radius:8px; background:#13243a; color:#e6eef6; border:1px solid rgba(255,255,255,0.04); cursor:pointer; }
  button.primary { background: linear-gradient(90deg,var(--accent), #6ddaff); color:#022033; font-weight:600; border:none; }
  .layout { display:grid; grid-template-columns: 1fr 420px; gap:16px; align-items:start; }
  .visual { text-align:center; padding:12px; }
  .circle { width:200px; height:200px; border-radius:50%; margin:10px auto; display:flex; align-items:center; justify-content:center; transition:transform .08s, background .08s; box-shadow:0 20px 50px rgba(0,0,0,0.6); background:linear-gradient(180deg,#0c1420,#07121a); }
  .circle.on { transform:scale(1.06); }
  .circle .label { font-size:26px; font-weight:700; letter-spacing:0.06em; color:#dff; }
  .progress { width:80%; height:12px; background:#0b1622; border-radius:8px; overflow:hidden; margin:12px auto; }
  .progress .fill { height:100%; width:0%; background:linear-gradient(90deg,var(--accent), #7af); transition:width .05s linear; }
  .qr-area { padding:12px; background:rgba(255,255,255,0.02); border-radius:8px; text-align:center; }
  textarea.code { width:100%; height:90px; background:transparent; color:#cfe8ff; border:1px dashed rgba(255,255,255,0.04); padding:8px; font-family:monospace; border-radius:6px; }
  #qrCanvas canvas { width:220px; height:220px; }
  .small { font-size:12px; color:var(--muted); margin-top:8px; }
  .row { display:flex; gap:8px; justify-content:center; margin-top:8px; }
  .hidden { display:none; }
  .flag-link { color:#ffd; text-decoration:underline; }
  footer { margin-top:12px; text-align:center; color:var(--muted); font-size:12px; }
</style>
</head>
<body>
  <div class="wrap">
    <header><h1>åŒæ­¥ç¯€æ‹å™¨ MVP â€” å³æ™‚å¯ç”¨ã€QR åˆ†äº«ã€ç›¸æ©Ÿæƒæã€Leader æ¨é€è¨­å®š</h1></header>

    <div class="panel layout">
      <!-- LEFT: main controls + visual -->
      <div>
        <div class="controls">
          <div class="control-group">
            <label>BPM</label>
            <input id="bpmSlider" type="range" min="40" max="240" value="120">
            <div id="bpmVal">120</div>
          </div>

          <div class="control-group">
            <label>æ‹/å°ç¯€</label>
            <select id="beatsPerBar">
              <option value="0">ç„¡</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4" selected>4</option>
              <option value="6">6</option>
            </select>
          </div>

          <div class="control-group">
            <label>Leader åç¨±</label>
            <input id="leaderName" type="text" value="">
          </div>
        </div>

        <div class="controls">
          <button id="enableSound" class="primary">å•Ÿç”¨è²éŸ³ï¼ˆå¿…è¦æ™‚é»ä¸€æ¬¡ï¼‰</button>
          <button id="startBtn">é–‹å§‹</button>
          <button id="stopBtn">åœæ­¢</button>
          <label style="display:flex;align-items:center;gap:6px;"><input id="mute" type="checkbox"> éœéŸ³</label>
        </div>

        <div class="visual">
          <div id="circle" class="circle"><div class="label" id="bpmLabel">120 BPM</div></div>
          <div class="progress"><div id="progressFill" class="fill"></div></div>
          <div class="small">è¦–è¦ºåŒ–åœ“åœˆèˆ‡æ‹å…§é€²åº¦ï¼›ç¬¬ä¸€æ‹ç‚ºå¼·æ‹ï¼ˆè‰²å½©åŠ å¼·ï¼‰</div>
        </div>

        <div style="margin-top:12px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap;">
          <button id="beLeader">æˆç‚º Leader</button>
          <button id="beFollower">åŠ å…¥ Leaderï¼ˆæƒ QRï¼‰</button>
          <button id="bleScanBtn">æƒæé™„è¿‘ Leaderï¼ˆBLEï¼‰</button>
        </div>

        <div id="scanInstructions" class="small">è‹¥æ¡Œæ©Ÿ Chrome ä¸æ”¯æ´ BLEï¼Œè«‹é–‹å•Ÿ <a class="flag-link" href="chrome://flags/#enable-experimental-web-platform-features">chrome://flags/#enable-experimental-web-platform-features</a>ï¼ˆAndroid Chrome å¯å¯¦é©—ï¼‰ã€‚</div>

      </div>

      <!-- RIGHT: QR / leader list / camera -->
      <div>
        <div id="qrPanel" class="qr-area hidden">
          <div><strong>Leader QRï¼ˆæƒæåŠ å…¥ï¼‰</strong></div>
          <div id="qrCanvas"></div>
          <div class="row">
            <button id="copySession">è¤‡è£½ä»£ç¢¼</button>
            <button id="downloadQR">ä¸‹è¼‰ QR</button>
            <button id="pasteAnswerBtn">è²¼ä¸Š Answer å®Œæˆé€£ç·š</button>
          </div>
          <div class="small">Leader QR åŒ…å«æœƒè©±èˆ‡ Offerï¼ˆè‹¥ follower æƒææœƒç”¢ç”Ÿ Answer ä¸¦è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼Œå›å‚³çµ¦ Leader è²¼ä¸Šå®Œæˆ P2Pï¼‰ã€‚</div>
        </div>

        <div id="followerPanel" class="qr-area hidden">
          <div><strong>æƒæ Leader QR æˆ– æ‰‹å‹•è²¼ä»£ç¢¼</strong></div>
          <div class="row">
            <button id="openCamera">ğŸ“· ç”¨ç›¸æ©Ÿæƒæ QR</button>
            <button id="cancelCamera" class="hidden">å–æ¶ˆæƒæ</button>
          </div>
          <video id="qrVideo" class="hidden" autoplay playsinline></video>
          <canvas id="qrCanvasHidden" class="hidden"></canvas>
          <div style="margin-top:8px;">
            <textarea id="manualSession" class="code" placeholder="æ‰‹å‹•è²¼ä¸Š Leader æä¾›çš„ä»£ç¢¼ï¼ˆæˆ–æƒæå¾Œè‡ªå‹•å¡«å…¥ï¼‰"></textarea>
            <div class="row">
              <button id="useManual">ä½¿ç”¨æ­¤ä»£ç¢¼åŠ å…¥</button>
            </div>
          </div>
          <div id="leaderList" class="small" style="text-align:left; margin-top:8px;"></div>
        </div>

        <div id="logs" class="small" style="margin-top:12px; max-height:260px; overflow:auto; text-align:left; background:rgba(255,255,255,0.02); padding:8px; border-radius:8px;"></div>
      </div>
    </div>

    <footer>èªªæ˜ï¼šè¦–è¦ºæœƒç«‹å³å•Ÿå‹•ï¼›ç€è¦½å™¨é€šå¸¸è¦ä½¿ç”¨è€…äº’å‹•æ‰èƒ½æ’­æ”¾è²éŸ³ï¼ˆæŒ‰ã€Œå•Ÿç”¨è²éŸ³ã€æˆ–ä»»æ„é»æ“Šç•«é¢å³å¯ï¼‰ã€‚QR èˆ‡ WebRTC æä¾›ç„¡ä¼ºæœå™¨ P2Pï¼ˆéœ€ä¸€æ¬¡æ€§è²¼å› Answerï¼‰ã€‚</footer>
  </div>

<script>
/* ====== åŸºæœ¬ç‹€æ…‹èˆ‡å…ƒç´  ====== */
const logEl = id('logs');
function log(s){ logEl.innerHTML += '['+new Date().toLocaleTimeString()+'] '+s+'<br>'; logEl.scrollTop = logEl.scrollHeight; }
function id(n){ return document.getElementById(n); }

const bpmSlider = id('bpmSlider');
const bpmVal = id('bpmVal');
const beatsPerBarSel = id('beatsPerBar');
const leaderNameInput = id('leaderName');
const startBtn = id('startBtn'), stopBtn = id('stopBtn'), enableSoundBtn = id('enableSound');
const muteCb = id('mute');
const circle = id('circle'), bpmLabel = id('bpmLabel'), progressFill = id('progressFill');

const beLeaderBtn = id('beLeader'), beFollowerBtn = id('beFollower'), bleScanBtn = id('bleScanBtn');
const qrPanel = id('qrPanel'), qrCanvas = id('qrCanvas'), copySessionBtn = id('copySession'), downloadQRBtn = id('downloadQR'), pasteAnswerBtn = id('pasteAnswerBtn');
const followerPanel = id('followerPanel'), openCameraBtn = id('openCamera'), cancelCameraBtn = id('cancelCamera');
const qrVideo = id('qrVideo'), qrCanvasHidden = id('qrCanvasHidden'), manualSessionTA = id('manualSession'), useManualBtn = id('useManual');
const leaderListDiv = id('leaderList');

/* ====== éŸ³è¨Šèˆ‡ scheduler ====== */
let audioCtx = null;
let masterGain = null;
let audioEnabled = false;
let scheduleTimer = null;
const lookaheadMs = 80;
const scheduleAheadSeconds = 0.5;

let running = false;
let localRole = 'single'; // 'single' | 'leader' | 'follower'
let bpm = Number(bpmSlider.value);
let beatsPerBar = Number(beatsPerBarSel.value);
let leaderConfig = null; // { bpm, beatsPerBar, startEpochMs, name } in epoch ms (Date.now())
let offsetMs = 0; // leaderTime - localTime (ms) for follower (computed by ping/pong)
let lastScheduledBeat = -1;

/* ====== WebRTC state for live updates (manual handshake via QR & copyback) ====== */
let pc = null, dataChannel = null;
let pendingOfferB64 = null; // for leader QR
let pingInterval = null;
let pingSamples = [];

/* ====== åˆå§‹åŒ– UI & ç«‹å³å•Ÿå‹•è¦–è¦ºï¼ˆç„¡è²ï¼‰ ====== */
function init() {
  leaderNameInput.value = 'ç¯€æ‹å™¨-' + randomSuffix(2);
  bpmVal.textContent = bpmSlider.value;
  bpmLabel.textContent = bpm + ' BPM';
  startVisualMetronome(); // immediate visual-only start so page is instantly usable
  attachEvents();
  log('é é¢åˆå§‹åŒ–å®Œæˆï¼šè¦–è¦ºåŒ–å·²å•Ÿå‹•ã€‚è‹¥è¦æœ‰è²éŸ³ï¼Œè«‹é»ã€Œå•Ÿç”¨è²éŸ³ã€æˆ–ä»»æ„é»æ“Šç•«é¢ä»¥è§£é™¤ç€è¦½å™¨è‡ªå‹•æ’­æ”¾é™åˆ¶ã€‚');
}
function randomSuffix(n=2){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let s=''; for(let i=0;i<n;i++) s+=chars[Math.floor(Math.random()*chars.length)];
  return s;
}

/* audio context lazy init & master gain */
function ensureAudio() {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = audioCtx.createGain();
    masterGain.gain.value = muteCb.checked ? 0 : 1;
    masterGain.connect(audioCtx.destination);
    log('AudioContext å»ºç«‹');
  }
}

/* enable audio on first user gesture */
function enableAudioByUserGesture(){
  if (audioEnabled) return;
  ensureAudio();
  if (audioCtx.state === 'suspended') {
    audioCtx.resume().then(()=> {
      audioEnabled = true;
      log('Audio å·²å•Ÿç”¨ï¼ˆä½¿ç”¨è€…äº’å‹•ï¼‰');
    });
  } else {
    audioEnabled = true;
    log('Audio å·²å•Ÿç”¨');
  }
}

/* audio click scheduled at audioCtx time */
function scheduleClickAt(audioTime, strong=false){
  if (!audioEnabled) return; // do nothing if audio not enabled
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.value = strong ? 1000 : 700;
  o.connect(g); g.connect(masterGain);
  g.gain.setValueAtTime(0, audioTime);
  g.gain.linearRampToValueAtTime(0.9, audioTime + 0.001);
  g.gain.exponentialRampToValueAtTime(0.001, audioTime + 0.12);
  o.start(audioTime); o.stop(audioTime + 0.13);
}

/* visual-only scheduler for immediate UX (uses perf.now) */
let visualTimer = null;
function startVisualMetronome(){
  // set default leaderConfig to local single-mode using epoch time reference
  leaderConfig = { bpm: Number(bpmSlider.value), beatsPerBar: Number(beatsPerBarSel.value), startEpochMs: Date.now(), name: leaderNameInput.value };
  lastScheduledBeat = -1;
  if (visualTimer) clearInterval(visualTimer);
  visualTimer = setInterval(()=> {
    const nowEpoch = Date.now();
    const intervalMs = 60000 / leaderConfig.bpm;
    const elapsed = nowEpoch - leaderConfig.startEpochMs;
    const beatIndex = Math.floor(Math.max(0, elapsed / intervalMs));
    const nextBeatTime = leaderConfig.startEpochMs + (beatIndex + 1) * intervalMs;
    const msToNext = nextBeatTime - nowEpoch;
    const frac = 1 - (msToNext / intervalMs);
    progressFill.style.width = `${Math.max(0,Math.min(1,frac))*100}%`;
    // flash circle when crossing threshold
    if (msToNext <  (intervalMs * 0.05) && (lastScheduledBeat !== beatIndex+1)) {
      const isStrong = (leaderConfig.beatsPerBar>0) ? (( (beatIndex+1) % leaderConfig.beatsPerBar) === 1 ) : false;
      flashVisual(isStrong);
      lastScheduledBeat = beatIndex+1;
    }
  }, 30);
}

/* flash visual circle */
function flashVisual(strong=false){
  circle.classList.add('on');
  circle.style.background = strong ? 'linear-gradient(90deg,var(--accent-strong), #ffb4b4)' : 'linear-gradient(90deg,var(--accent), #7af)';
  setTimeout(()=> { circle.classList.remove('on'); circle.style.background='linear-gradient(180deg,#0c1420,#07121a)'; }, 90);
}

/* audio+precise scheduler using WebAudio's time (schedules ahead) */
function startScheduler() {
  if (scheduleTimer) return;
  lastScheduledBeat = -1;
  scheduleTimer = setInterval(schedulerTick, lookaheadMs);
  log('ç²¾æº–æ’ç¨‹å™¨å·²å•Ÿå‹•');
}
function stopScheduler() {
  if (scheduleTimer) { clearInterval(scheduleTimer); scheduleTimer = null; }
  lastScheduledBeat = -1;
  log('ç²¾æº–æ’ç¨‹å™¨å·²åœæ­¢');
}
function schedulerTick(){
  if (!leaderConfig) return;
  const localNowPerf = performance.now();
  // leaderEpochMs - localEpochMs = leaderEpochMs - Date.now(); but we need leader time in perf space
  // Use: leaderPerfNow = localPerfNow + (leaderEpochMs - Date.now())
  const epochToPerfDelta = leaderConfig.startEpochMs - Date.now(); // leader.startEpochMs - current local epoch
  const leaderNowPerf = localNowPerf + epochToPerfDelta + offsetMs; // add offset for follower
  const intervalMs = 60000 / leaderConfig.bpm;
  const aheadMs = scheduleAheadSeconds * 1000;
  const maxBeatToSchedule = Math.floor((leaderNowPerf + aheadMs - (convertEpochToPerf(leaderConfig.startEpochMs))) / intervalMs);

  for (let b = Math.max(lastScheduledBeat+1, 0); b <= maxBeatToSchedule; b++){
    const beatLeaderPerf = convertBeatIndexToLeaderPerf(b);
    const localPlayDelayMs = beatLeaderPerf - localNowPerf - offsetMs;
    if (localPlayDelayMs < -80) { lastScheduledBeat = b; continue; }
    const playAtAudioTime = audioEnabled && audioCtx ? (audioCtx.currentTime + Math.max(0, localPlayDelayMs/1000)) : null;
    const inBarIndex = leaderConfig.beatsPerBar > 0 ? (b % leaderConfig.beatsPerBar) : -1;
    const strong = (leaderConfig.beatsPerBar>0 && inBarIndex === 0);
    if (playAtAudioTime && audioEnabled) scheduleClickAt(playAtAudioTime, strong);
    // schedule visual flash
    setTimeout(()=> { flashVisual(strong); }, Math.max(0, localPlayDelayMs));
    lastScheduledBeat = b;
  }
  // update progress fill based on leaderNowPerf
  const elapsedMs = leaderNowPerf - convertEpochToPerf(leaderConfig.startEpochMs);
  const curBeatIndex = Math.max(0,Math.floor(elapsedMs / (60000/leaderConfig.bpm)));
  const nextBeatPerf = convertBeatIndexToLeaderPerf(curBeatIndex+1);
  const frac = 1 - ((nextBeatPerf - leaderNowPerf) / (60000/leaderConfig.bpm));
  progressFill.style.width = `${Math.max(0,Math.min(1,frac))*100}%`;
}
function convertEpochToPerf(epochMs){
  // approximate: performance.now() corresponds to Date.now() -> compute perf time for given epoch
  return performance.now() + (epochMs - Date.now());
}
function convertBeatIndexToLeaderPerf(beatIdx){
  const intervalMs = 60000 / leaderConfig.bpm;
  return convertEpochToPerf(leaderConfig.startEpochMs) + beatIdx * intervalMs;
}

/* ====== UI events ====== */
function attachEvents(){
  // audio enable button & any first click anywhere enables audio
  enableSoundBtn.addEventListener('click', ()=> { enableAudioByUserGesture(); startScheduler(); });
  document.body.addEventListener('pointerdown', () => { if(!audioEnabled) { enableAudioByUserGesture(); startScheduler(); } }, { once:true });

  bpmSlider.addEventListener('input', ()=> {
    bpm = Number(bpmSlider.value); bpmVal.textContent = bpm; bpmLabel.textContent = `${bpm} BPM`;
    // if leader, update leaderConfig and push to followers
    if (localRole === 'leader') {
      scheduleLeaderConfigUpdate({ bpm });
    } else {
      // update local visual/leaderConfig for single mode
      leaderConfig.bpm = bpm;
    }
  });
  beatsPerBarSel.addEventListener('change', ()=> {
    beatsPerBar = Number(beatsPerBarSel.value);
    if (localRole === 'leader') scheduleLeaderConfigUpdate({ beatsPerBar });
    else leaderConfig.beatsPerBar = beatsPerBar;
  });
  startBtn.addEventListener('click', ()=> {
    // start local scheduler (will use leaderConfig)
    if (!leaderConfig) leaderConfig = { bpm, beatsPerBar, startEpochMs: Date.now(), name: leaderNameInput.value };
    startScheduler();
    log('æŒ‰ä¸‹é–‹å§‹ï¼ˆç²¾æº–æ’ç¨‹å•Ÿå‹•ï¼‰');
  });
  stopBtn.addEventListener('click', ()=> {
    stopScheduler();
    log('æŒ‰ä¸‹åœæ­¢ï¼ˆç²¾æº–æ’ç¨‹åœæ­¢ï¼‰');
  });

  beLeaderBtn.addEventListener('click', async ()=> {
    localRole = 'leader';
    leaderConfig = { bpm: Number(bpmSlider.value), beatsPerBar: Number(beatsPerBarSel.value), startEpochMs: Date.now(), name: leaderNameInput.value || ('ç¯€æ‹å™¨-'+randomSuffix(2)) };
    // create RTCPeerConnection & dataChannel
    await createLeaderOfferAndShowQR();
    qrPanel.classList.remove('hidden');
    followerPanel.classList.add('hidden');
    log('å·²æˆç‚º Leaderï¼ˆQR å·²ç”¢ç”Ÿï¼Œscan å¾Œ follower æœƒå›å‚³ Answerï¼‰');
    // also start local scheduler & send config once datachannel opens
    startScheduler();
  });

  pasteAnswerBtn.addEventListener('click', async ()=> {
    // Leader pastes follower's answer (from clipboard or prompt)
    const ans = prompt('è«‹è²¼ä¸Š follower æä¾›çš„ Answerï¼ˆå¾ follower è¤‡è£½éä¾†ï¼‰ï¼š');
    if (!ans) return;
    try {
      const answer = JSON.parse(atob(ans));
      await pc.setRemoteDescription(new RTCSessionDescription(answer));
      log('Leader: å·²è¨­å®š remoteDescription (answer)ã€‚');
    } catch(e) { log('Leader è¨­å®š Answer å¤±æ•—ï¼š'+e); alert('è²¼ä¸Š Answer å¤±æ•—ï¼š'+e); }
  });

  beFollowerBtn.addEventListener('click', ()=> {
    localRole = 'follower';
    followerPanel.classList.remove('hidden');
    qrPanel.classList.add('hidden');
  });

  openCameraBtn.addEventListener('click', ()=> startCameraScan());
  cancelCameraBtn.addEventListener('click', ()=> stopCameraScan());
  useManualBtn.addEventListener('click', ()=> {
    const txt = manualSessionTA.value.trim();
    if (!txt) return alert('è«‹è²¼ä¸Š Leader ä»£ç¢¼å¾Œå†æŒ‰æ­¤');
    try { const session = JSON.parse(atob(txt)); useScannedSession(session); } catch(e){ alert('ä»£ç¢¼è§£æå¤±æ•—ï¼š'+e); }
  });

  bleScanBtn.addEventListener('click', ()=> {
    if (!('bluetooth' in navigator) || !navigator.bluetooth.requestLEScan) {
      alert('æ­¤ç€è¦½å™¨ä¸æ”¯æ´ BLE æƒæï¼ˆæˆ–éœ€é–‹å•Ÿ chrome flagsï¼‰ã€‚');
      return;
    }
    // BLE scan (experimental) - show available advertisements
    startBLEScan();
  });
  // mute control
  muteCb.addEventListener('change', ()=> {
    if (masterGain) masterGain.gain.setValueAtTime(muteCb.checked ? 0 : 1, audioCtx.currentTime);
  });
}

/* ====== WebRTC offer in QR (leader) ====== */
async function createLeaderOfferAndShowQR(){
  // create pc
  if (pc) try{ pc.close(); }catch(e){}
  pc = new RTCPeerConnection();
  pc.onconnectionstatechange = ()=> log('PC state: '+pc.connectionState);
  dataChannel = pc.createDataChannel('sync');
  setupDataChannel(dataChannel, true);

  // create offer
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  const session = {
    type:'leaderSession',
    name: leaderConfig.name,
    bpm: leaderConfig.bpm,
    beatsPerBar: leaderConfig.beatsPerBar,
    startEpochMs: leaderConfig.startEpochMs,
    offer: offer // include full offer object (may be large)
  };
  const sessionB64 = btoa(JSON.stringify(session));
  pendingOfferB64 = sessionB64;
  // render QR
  qrCanvas.innerHTML = '';
  try { QRCode.toCanvas(qrCanvas, sessionB64, { width:220 }); } catch(e){ log('QR ç”Ÿæˆå¤±æ•—ï¼š'+e); }
  // copy button handler
  copySessionBtn.onclick = async ()=> {
    try { await navigator.clipboard.writeText(sessionB64); log('Leader session å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿'); alert('å·²è¤‡è£½ï¼Œè²¼çµ¦ follower æƒææˆ–è²¼ä¸Š'); } catch(e){ alert('è¤‡è£½å¤±æ•—ï¼Œè«‹æ‰‹å‹•é¸å–'); }
  };
  downloadQRBtn.onclick = ()=> {
    const canv = qrCanvas.querySelector('canvas'); if (!canv) return alert('QR å°šæœªç”Ÿæˆ');
    const url = canv.toDataURL('image/png'); const a=document.createElement('a'); a.href=url; a.download='leader-session.png'; a.click();
  };
}

/* data channel handlers */
function setupDataChannel(ch, isLeader) {
  ch.onopen = ()=> {
    log('DataChannel open (' + (isLeader?'leader':'follower') + ')');
    if (isLeader) {
      // send current config immediately
      sendConfigToFollowers();
    } else {
      // follower starts pinging for offset measurement
      if (pingInterval) clearInterval(pingInterval);
      pingInterval = setInterval(()=> {
        try { ch.send(JSON.stringify({ type:'ping', t0: performance.now() })); } catch(e){ }
      }, 1500);
    }
  };
  ch.onmessage = (ev)=> {
    try {
      const msg = JSON.parse(ev.data);
      if (msg.type === 'ping' && dataChannel && localRole === 'leader') {
        const t1 = performance.now();
        dataChannel.send(JSON.stringify({ type:'pong', t0:msg.t0, t1 }));
      } else if (msg.type === 'pong' && localRole === 'follower') {
        const t3 = performance.now();
        const t0 = msg.t0, t1 = msg.t1;
        const rtt = t3 - t0;
        const estimatedLeaderNow = t1 + rtt/2;
        const newOffset = estimatedLeaderNow - t3;
        pingSamples.push(newOffset); if (pingSamples.length>9) pingSamples.shift();
        const sorted = [...pingSamples].sort((a,b)=>a-b);
        offsetMs = sorted[Math.floor(sorted.length/2)];
        log('offsetSamples='+pingSamples.map(x=>x.toFixed(1)).join(', ') + ' => offset=' + offsetMs.toFixed(1) + ' ms');
      } else if (msg.type === 'config') {
        // follower receives leader config update
        leaderConfig = { bpm: msg.bpm, beatsPerBar: msg.beatsPerBar, startEpochMs: msg.startEpochMs, name: msg.name };
        bpmSlider.value = leaderConfig.bpm; bpmVal.textContent = leaderConfig.bpm;
        beatsPerBarSel.value = leaderConfig.beatsPerBar;
        log('æ”¶åˆ° leader config update: BPM='+leaderConfig.bpm+', beatsPerBar='+leaderConfig.beatsPerBar);
        // start scheduler if not started
        startScheduler();
      }
    } catch(e){ log('è™•ç† datachannel è¨Šæ¯å¤±æ•—: '+e); }
  };
  ch.onclose = ()=> { log('DataChannel closed'); if (pingInterval) clearInterval(pingInterval); pingInterval=null; };
}

/* leader: send config to connected followers */
function sendConfigToFollowers(){
  if (dataChannel && dataChannel.readyState === 'open') {
    const cfg = { type:'config', bpm: leaderConfig.bpm, beatsPerBar: leaderConfig.beatsPerBar, startEpochMs: leaderConfig.startEpochMs, name: leaderConfig.name };
    try { dataChannel.send(JSON.stringify(cfg)); log('Leader: å·²ç™¼é€ config'); } catch(e){ log('Leader: ç™¼ config å¤±æ•—:'+e); }
  }
}

/* when leader changes bpm/beats: schedule update to take effect slightly in future and push to followers */
function scheduleLeaderConfigUpdate(changes){
  // compute new config with future effective time (short grace for propagation)
  const graceMs = 500; // 0.5s to give followers time
  leaderConfig = leaderConfig || { bpm, beatsPerBar, startEpochMs: Date.now(), name: leaderNameInput.value };
  if (changes.bpm !== undefined) leaderConfig.bpm = changes.bpm;
  if (changes.beatsPerBar !== undefined) leaderConfig.beatsPerBar = changes.beatsPerBar;
  // set startEpochMs to now + small offset so everyone switches in sync
  leaderConfig.startEpochMs = Date.now() + graceMs;
  leaderConfig.name = leaderNameInput.value || leaderConfig.name;
  // update QR immediately as well
  if (pendingOfferB64) {
    // we regenerate the minimal session object for QR that includes latest config and still includes offer
    try {
      const old = JSON.parse(atob(pendingOfferB64));
      old.bpm = leaderConfig.bpm;
      old.beatsPerBar = leaderConfig.beatsPerBar;
      old.startEpochMs = leaderConfig.startEpochMs;
      const newB64 = btoa(JSON.stringify(old));
      pendingOfferB64 = newB64;
      qrCanvas.innerHTML = '';
      QRCode.toCanvas(qrCanvas, pendingOfferB64, { width:220 });
    } catch(e){ /* ignore */ }
  }
  // send live config via dataChannel if open
  sendConfigToFollowers();
  // update local scheduler to adopt new config at startEpochMs
  startScheduler();
}

/* ====== Camera QR scan for follower (with cancel) ====== */
let cameraStream = null;
let scanTick = null;
async function startCameraScan(){
  try {
    cameraStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
    qrVideo.srcObject = cameraStream;
    qrVideo.classList.remove('hidden');
    qrCanvasHidden.classList.remove('hidden');
    openCameraBtn.classList.add('hidden');
    cancelCameraBtn.classList.remove('hidden');
    followerPanelScrollIntoView();
    scanTick = requestAnimationFrame(scanLoop);
    log('ç›¸æ©Ÿæƒæå·²å•Ÿå‹•');
  } catch(e) { alert('å•Ÿå‹•ç›¸æ©Ÿå¤±æ•—ï¼š' + e); log('ç›¸æ©Ÿå•Ÿå‹•å¤±æ•—ï¼š'+e); }
}
function stopCameraScan(){
  if (cameraStream) cameraStream.getTracks().forEach(t=>t.stop());
  cameraStream = null;
  qrVideo.classList.add('hidden');
  qrCanvasHidden.classList.add('hidden');
  openCameraBtn.classList.remove('hidden');
  cancelCameraBtn.classList.add('hidden');
  if (scanTick) cancelAnimationFrame(scanTick);
  scanTick = null;
  log('ç›¸æ©Ÿæƒæå·²å–æ¶ˆ');
}
function followerPanelScrollIntoView(){ try{ followerPanel.scrollIntoView({behavior:'smooth'});}catch(e){}; }
function scanLoop(){
  if (!cameraStream) return;
  const video = qrVideo, canvas = qrCanvasHidden, ctx = canvas.getContext('2d');
  if (video.readyState === video.HAVE_ENOUGH_DATA) {
    canvas.width = video.videoWidth; canvas.height = video.videoHeight;
    ctx.drawImage(video,0,0,canvas.width,canvas.height);
    const img = ctx.getImageData(0,0,canvas.width,canvas.height);
    const code = jsQR(img.data, canvas.width, canvas.height);
    if (code) {
      // found QR
      try {
        const session = JSON.parse(atob(code.data));
        log('æƒæåˆ° session');
        stopCameraScan();
        useScannedSession(session);
        return;
      } catch(e) {
        log('QR å…§å®¹è§£æå¤±æ•—ï¼š'+e);
      }
    }
  }
  scanTick = requestAnimationFrame(scanLoop);
}

/* ====== Use session scanned/ pasted by follower ====== */
async function useScannedSession(session){
  // session should be object containing offer (for P2P) or minimal config
  if (!session) { alert('session ç„¡æ•ˆ'); return; }
  if (session.offer) {
    // this is leaderSession with Offer object -> perform WebRTC Answer
    try {
      // create pc
      if (pc) try{ pc.close(); }catch(e){}
      pc = new RTCPeerConnection();
      pc.ondatachannel = (ev)=> { dataChannel = ev.channel; setupDataChannel(dataChannel, false); };
      await pc.setRemoteDescription(new RTCSessionDescription(session.offer));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      // copy answer to clipboard for follower to send back to leader (manual step)
      const answerB64 = btoa(JSON.stringify(answer));
      try { await navigator.clipboard.writeText(answerB64); alert('Answer å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼Œè«‹è²¼å›çµ¦ Leaderï¼ˆè®“ Leader è²¼ä¸Šå®Œæˆé€£ç·šï¼‰'); }
      catch(e){ prompt('è«‹å°‡é€™æ®µ Answer å›å‚³çµ¦ Leaderï¼š', answerB64); }
      // also set preliminary leaderConfig from session's config (so follower can immediate align)
      leaderConfig = { bpm: session.bpm, beatsPerBar: session.beatsPerBar, startEpochMs: session.startEpochMs, name: session.name };
      bpmSlider.value = leaderConfig.bpm; bpmVal.textContent = leaderConfig.bpm; beatsPerBarSel.value = leaderConfig.beatsPerBar;
      startScheduler();
      log('å·²å»ºç«‹æœ¬åœ° Answerï¼ˆå·²è¤‡è£½ï¼‰ï¼Œè«‹å›å‚³çµ¦ Leader å®Œæˆ P2P');
    } catch(e){ log('å»ºç«‹ Answer å¤±æ•—ï¼š'+e); alert('å»ºç«‹ Answer å¤±æ•—ï¼š'+e); }
  } else {
    // minimal session (no offer) -> just use config directly
    leaderConfig = { bpm: session.bpm, beatsPerBar: session.beatsPerBar, startEpochMs: session.startEpochMs, name: session.name };
    bpmSlider.value = leaderConfig.bpm; bpmVal.textContent = leaderConfig.bpm; beatsPerBarSel.value = leaderConfig.beatsPerBar;
    startScheduler();
    log('ä½¿ç”¨ leader çš„è¨­å®šé–‹å§‹åŒæ­¥ï¼ˆé P2P æ¨¡å¼ï¼Œç„¡ RTT æ ¡æ­£ï¼‰');
  }
}

/* ====== BLE scanning (experimental, may not work on desktop) ====== */
async function startBLEScan(){
  if (!('bluetooth' in navigator) || !navigator.bluetooth.requestLEScan) {
    alert('æ­¤ç€è¦½å™¨ä¸æ”¯æ´ BLE æƒæï¼ˆæˆ–éœ€æ‰“é–‹ Chrome flagsï¼‰ã€‚');
    return;
  }
  const scan = await navigator.bluetooth.requestLEScan({ acceptAllAdvertisements:true, keepRepeatedDevices:true });
  leaderListDiv.innerHTML = '<div>æ­£åœ¨æƒæ Nearby BLE å»£æ’­...</div>';
  navigator.bluetooth.addEventListener('advertisementreceived', ev => {
    // try parse manufacturerData -> as demo we expect base64 JSON in manufacturerData with key 0xFFFF
    try {
      for (const [key, value] of ev.manufacturerData.entries()) {
        const arr = new Uint8Array(value.buffer);
        const txt = new TextDecoder().decode(arr);
        try {
          const obj = JSON.parse(txt);
          const btn = document.createElement('button');
          btn.textContent = `${obj.name} (BPM ${obj.bpm})`;
          btn.onclick = ()=> useScannedSession(obj);
          leaderListDiv.appendChild(btn);
        } catch(e){}
      }
    } catch(e){ log('BLE adv parse error: '+e); }
  });
  setTimeout(()=> { try{ scan.stop(); log('BLE æƒæåœæ­¢ï¼ˆtimeoutï¼‰'); }catch(e){} }, 30000);
}

/* ====== Helper: copy text fallback ====== */
async function copyToClipboard(text){
  try { await navigator.clipboard.writeText(text); log('å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿'); return true; }
  catch(e){ log('è¤‡è£½åˆ°å‰ªè²¼ç°¿å¤±æ•—ï¼š'+e); return false; }
}

/* ====== Boot ====== */
init();

</script>
</body>
</html>
